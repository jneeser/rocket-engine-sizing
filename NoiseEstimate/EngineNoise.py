import numpy as np
from matplotlib import pyplot as plt
import os

from scipy.optimize import bisect


            
class PressureVessel():
    def __init__(self, burst_pressure, tank_volume, atmospheric_pressure, n_grid=100, max_distance=30.0):
        """Noise generated by pressure vessel bursting, based on estimating an equivalent explosive charge

        Args:
            burst_pressure (float): pressure at which the pressure vessel is expected to fail (Pa)
            tank_volume (float): pressure vessel volume (m^3)
            atmospheric_pressure (float): ambient pressure (Pa)
            n_grid (int, optional): number of grid points in radial circumferential direction. Defaults to 100.
            max_distance (float, optional): maximum distance considered in analysis. Defaults to 30.
        """
        self.P_burst      = burst_pressure                                   # predicted burst presssure at minimum safety factor [Pa]
        self.V_tank       = tank_volume                                      # volume of the pressure vessel [m^3]
        self.P_atm        = atmospheric_pressure                             # local atmospheric pressure [Pa]
        self.n_grid       = n_grid                                           # grid points
        self.max_distance = max_distance                                     # maximum resolved distance from the pressure vessel [m]
        self.gamma        = 1.4                                              # ratio of specific heats of air
        self.E_tnt        = 4.148e6                                          # Energy of TNT [J/kg]

    def TNT_equivalent(self):
        # TNT equivalence of a pressure vessel assuming isentropic expansion
        # Energy release
        self.E_burst = self.P_burst * self.V_tank / (self.gamma - 1) * (1 - (self.P_atm / self.P_burst)**((self.gamma - 1) / self.gamma))

        # TNT equivalent mass
        self.M_tnt = self.E_burst / self.E_tnt

    def noise_distribution(self): 
        self.angles = np.linspace(0, 2*np.pi, self.n_grid)
        self.radii  = np.linspace(0, self.max_distance, self.n_grid)
        self.sound_levels = np.ndarray((self.n_grid, self.n_grid))

        
        # pressure rise and noise power
        for i in range(round(self.n_grid / 2)):
            for j in range(self.n_grid): 
                
                if self.radii[j] < 1:
                    # set anything below 1m distance to 1m value
                    dP = 0.95 * self.M_tnt**(1/3) + 3.9 * self.M_tnt**(2/3) + 13 * self.M_tnt
                else:
                    dP = 0.95 * self.M_tnt**(1/3)/self.radii[j] + 3.9 * self.M_tnt**(2/3)/self.radii[j]**2 + 13 * self.M_tnt/self.radii[j]**3
                
                self.sound_levels[i][j] = 20 * np.log(dP/20e-6)
                self.sound_levels[self.n_grid-1-i][j] = self.sound_levels[i][j]


class ExplosiveCharge():
    def __init__(self, NEM, TNT_equivalence=0.43, n_grid=100, max_distance=30.0):
        """Noise generated by an undeflected explosive charge

        Args:
            NEM (float): Net explosive mass (kg)
            TNT_equivalence (float, optional): TNT equivalence factor. Defaults to 0.43 (for black powder).
            n_grid (int, optional): number of grid points in radial circumferential direction. Defaults to 100.
            max_distance (float, optional): maximum distance considered in analysis. Defaults to 30.
        """        
        self.TNT_equivalence = TNT_equivalence                                  # TNT equivelnce factor for pressure. Black powder = 0.43
        self.NEM             = NEM                                              # net explosive mass [kg]
        self.n_grid           = n_grid                                          # grid points
        self.max_distance     = max_distance                                    # maximum resolved distance from the motor [m]
        self.gamma           = 1.4                                              # ratio of specific heats of air
        self.E_tnt           = 4.148e6                                          # Energy of TNT [J/kg]
        
    def noise_distribution(self): 
        self.angles = np.linspace(0, 2*np.pi, self.n_grid)
        self.radii  = np.linspace(0, self.max_distance, self.n_grid)
        self.sound_levels = np.ndarray((self.n_grid, self.n_grid))

        # Net Explosive Mass in TNT equivalent
        self.M_tnt = self.NEM * self.TNT_equivalence
        
        # pressure rise and noise power
        for i in range(round(self.n_grid / 2)):
            for j in range(self.n_grid): 
                
                if self.radii[j] < 1:
                    # set anything below 1m distance to 1m value
                    dP = 0.95 * self.M_tnt**(1/3) + 3.9 * self.M_tnt**(2/3) + 13 * self.M_tnt
                else:
                    dP = 0.95 * self.M_tnt**(1/3)/self.radii[j] + 3.9 * self.M_tnt**(2/3)/self.radii[j]**2 + 13 * self.M_tnt/self.radii[j]**3
                
                self.sound_levels[i][j] = 20 * np.log(dP/20e-6)
                self.sound_levels[self.n_grid-1-i][j] = self.sound_levels[i][j]


class RocketMotor():
    def __init__(self, thrust, exhaust_velocity, scaling_factor=0.0012, n_grid=100, max_distance=30.0):
        """Undeflected rocket exhaust model based on NASA-SP-8072 "Acoustic loads generated by the propulsion system"

        Args:
            thrust (float): Engine thrust (N)
            exhaust_velocity (float): Nozzle exhaust velocity (m/s)
            scaling_factor (float, optional): emperical scaling factor for noise power. Defaults to 0.0012 (derived from solid rocket motor tests)
            n_grid (int, optional): number of grid points in radial circumferential direction. Defaults to 100.
            max_distance (float, optional): maximum distance considered in analysis. Defaults to 30.
        """
        self.thrust           = thrust
        self.exhaust_velocity = exhaust_velocity
        self.scaling_factor   = scaling_factor                  # scaling factor for noise power in relation to engine power. 0.0012, determined experimentally
        self.n_grid           = n_grid                          # grid points
        self.max_distance     = max_distance                    # maximum resolved distance from the motor [m]

    def noise_power(self):

        self.P_noise       = 0.5 * self.scaling_factor * self.exhaust_velocity * self.thrust 
        # conversion to dB
        self.max_noise_lvl = 10 * np.log10(self.P_noise * 1e12)


    def noise_distance(self, distance):
        return 10 * np.log10(self.P_noise * 1e12 / (2 * np.pi * distance**2))

    def noise_direction(self, theta, radius):
        # NASA noise model for strauhal number of 0.4, taken from fig.10
        angular_dist =  -2.20411*theta**4 + 19.43914*theta**3 - 59.41912*theta**2 + 64.91368*theta - 18.73118 
        Lw = 10 * np.log10(self.P_noise) + 120
        noise_dist = angular_dist + Lw - 10*np.log10(radius**2) - 11 
    
        return noise_dist

    def noise_distribution(self):
        self.angles = np.linspace(0, 2*np.pi, self.n_grid)
        self.radii  = np.linspace(0, self.max_distance, self.n_grid)
        self.sound_levels = np.ndarray((self.n_grid, self.n_grid))

        # Noise model undefined for a distance of 0 m 
        self.sound_levels[:][0] = np.ones(self.n_grid) * self.max_noise_lvl
        self.sound_levels[:,0]  = np.ones(self.n_grid) * self.max_noise_lvl

        for i in range(round(self.n_grid / 2)):
            for j in range(1,self.n_grid): 
                
                self.sound_levels[i][j] = self.noise_direction(self.angles[i], self.radii[j])
                self.sound_levels[self.n_grid-1-i][j] = self.sound_levels[i][j]


def contour_plot(noise_source, folder, name, save_fig=False):   
    try:
        os.mkdir(folder) 
    except:
        pass

    r, theta = np.meshgrid(noise_source.radii, noise_source.angles)   
    
    fig, ax  = plt.subplots(subplot_kw = dict(projection='polar'))
    cp       = ax.contourf(theta, r, noise_source.sound_levels)
    fig.colorbar(cp, label='noise [dB]')
    
    if save_fig:
        fig.savefig(folder + '/' + name + '.png', dpi = 600, transparent=True)
    else:
        plt.show()

                
def validation():
    # tuning of the model constant using test data of three solid rocket motors
    # test data
    thrust           = np.array([398, 524, 683])                        # N
    exhaust_velocity = 1295                                             # m/s
    r_probe          = 20                                               # m
    theta_probe      = np.pi/2  
    measured_noise   = np.array([105.6, 107.4, 109.7])                  # dB

    constant         = np.ndarray(len(thrust))

    for i in range(len(thrust)):
        def func(const):
            sound = RocketMotor(thrust[i], exhaust_velocity, scaling_factor=const)
            sound.noise_power()

            return measured_noise[i] - sound.noise_direction(theta_probe, r_probe)
        
        constant[i] = bisect(func, 1e-4, 1e-2)

    print('mean sclaing factor from test data: ', np.mean(constant))
            

if __name__ == "__main__":
    thrust = 29.01                      # [N]
    exhaust_velocity = 1143.66             # [m/s]

    thrust = RocketMotor(thrust, exhaust_velocity, scaling_factor=0.0012)
    thrust.noise_power()
    thrust.noise_distribution()

    burst_pressure = 123.5e6            # Pa
    chamber_radius = 7e-3               # m
    chamber_length = 7e-2               # m
    chamber_volume = np.pi * chamber_radius**2 * chamber_length
    ambient_pressure = 101325           # Pa

    burst = PressureVessel(burst_pressure, chamber_volume, ambient_pressure)
    burst.TNT_equivalent()
    burst.noise_distribution()


    contour_plot(thrust, 'Figures', 'thrust', save_fig=True)
    contour_plot(burst, 'Figures', 'burst', save_fig=True)

